/*****************************************************************
 * DO NOT EDIT - MACHINE-GENERATED FILE!
 * 
 * Source file : ../../../src/root/logger.idl
 * Platform    : V4 Generic
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.1.0 (roadrunner) on 01/02/2010 22:26
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#if !defined(__logger_server_h__)
#define __logger_server_h__

#define IDL4_OMIT_FRAME_POINTER 0
#define IDL4_USE_FASTCALL 0
#define IDL4_NEED_MALLOC 1
#define IDL4_API v4
#define IDL4_ARCH generic

#include "idl4/idl4.h"

#if defined(IDL4_HEADER_REVISION) && IDL4_HEADER_REVISION < 20060813
#error You are using outdated versions of the IDL4 header files
#endif /* defined(IDL4_HEADER_REVISION) && IDL4_HEADER_REVISION < 20060813 */

#include "sdi/types.h"
#include "sdi/types.h"
#include "sdi/types.h"

#define IF_LOGGING_ID 1

#define IF_LOCATOR_ID 2

#define MAX_INTERFACEID 8

#if !defined(_typedef___interfaceid_t)
#define _typedef___interfaceid_t
typedef CORBA_char  interfaceid_t;
#endif /* !defined(_typedef___interfaceid_t) */

#if !defined(_typedef___logmessage_t)
#define _typedef___logmessage_t
typedef CORBA_char * logmessage_t;
#endif /* !defined(_typedef___logmessage_t) */

#if !defined(_typedef___buffer_t)
#define _typedef___buffer_t
typedef struct {
  CORBA_unsigned_long  _maximum;
  CORBA_unsigned_long  _length;
  CORBA_char * _buffer;
}  buffer_t;
#endif /* !defined(_typedef___buffer_t) */

#define ex_type_conflict 1

#if !defined(_typedef___type_conflict)
#define _typedef___type_conflict
typedef struct type_conflict  type_conflict;
#endif /* !defined(_typedef___type_conflict) */

/* Interface IF_LOGGING */

void  IF_LOGGING_server();
void  IF_LOGGING_discard();

#define IF_LOGGING_DEFAULT_VTABLE { (void*)&service_IF_LOGGING_LogMessage }
#define IF_LOGGING_DEFAULT_VTABLE_SIZE 1
#define IF_LOGGING_MAX_FID 0
#define IF_LOGGING_MSGBUF_SIZE 64
#define IF_LOGGING_STRBUF_SIZE 2
#define IF_LOGGING_FID_MASK 0x0

typedef union {
  struct {
    idl4_word_t  _msgtag;
    idl4_word_t  _message_size;
    idl4_stringitem  _memmsg;
  }  _in;
  struct {
    idl4_word_t  _spacer[64];
    idl4_word_t  _msgtag;
  }  _out;
  struct {
    idl4_word_t  _spacer[128];
    idl4_inverse_stringitem  _str[16];
    idl4_word_t  _acceptor;
  }  _buf;
}  _param_IF_LOGGING_LogMessage;

typedef union {
  struct {
    CORBA_char  _varbuf[256];
  }  _in;
}  _memmsg_IF_LOGGING_LogMessage;

idl4_word_t  service_IF_LOGGING_LogMessage(idl4_threadid_t  _caller, _param_IF_LOGGING_LogMessage * _par);

inline void  IF_LOGGING_LogMessage_implementation(CORBA_Object  _caller, const logmessage_t  message, idl4_server_environment * _env);

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: idl4_word_t  _message_size   2    4    4    4 x----  -1
//   M0: char _varbuf                 5    0  256    4 -----  -1
//   M-: CORBA_char  _message_buf     2   -1  256    1 x----  -1
//   S0: char message                 2    0  256    1 -----   0
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         4   -1    4    4 -p---  -1

#define IDL4_PUBLISH_IF_LOGGING_LOGMESSAGE(_func) idl4_word_t  service_IF_LOGGING_LogMessage(idl4_threadid_t  _caller, _param_IF_LOGGING_LogMessage * _par)\
\
{ \
  idl4_server_environment  _env; \
  CORBA_char * g1; \
  idl4_word_t  _memvaridx = 0; \
  _memmsg_IF_LOGGING_LogMessage * _memmsg = (_memmsg_IF_LOGGING_LogMessage *)_par->_buf._str[15].ptr; \
\
  _env._action = 0;\
\
  /* unmarshal */ \
   \
  g1 = (CORBA_char *)&_memmsg->_in._varbuf[_memvaridx];\
  _memvaridx += ((_par->_in._message_size+3) & 0xFFFFFFFCU);\
\
  /* invoke service */ \
   \
  _func(_caller, g1, &_env);\
\
  if (IDL4_EXPECT_TRUE(_env._action == 0)) \
    { \
      /* jump back */ \
       \
      _par->_out._msgtag = (0 << 6)+0;\
      return 0; \
    } \
\
  return 4294967295U; \
} \

#define IDL4_PUBLISH_IF_LOGGING_LogMessage IDL4_PUBLISH_IF_LOGGING_LOGMESSAGE

static inline void  IF_LOGGING_LogMessage_reply(CORBA_Object  _client)

{
  struct _reply_buffer {
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  }  _buf;
  struct _reply_buffer * _par = &_buf;

  /* send message */
  
  _buf._out._msgtag = 0;
  L4_MsgLoad((L4_Msg_t *)((void*)_par));
  L4_Send_Timeout(_client, L4_ZeroTime);
}

/* Interface logger */

void  logger_server();
void  logger_discard();

#define LOGGER_DEFAULT_VTABLE_1 { (void*)&service_logger_LogMessage }
#define LOGGER_DEFAULT_VTABLE_DISCARD { (void*)&logger_discard }
#define LOGGER_DEFAULT_VTABLE_SIZE 1
#define LOGGER_MAX_FID 0
#define LOGGER_MSGBUF_SIZE 64
#define LOGGER_STRBUF_SIZE 2
#define LOGGER_FID_MASK 0x0
#define LOGGER_IID_MASK 0x1

// Inherited from IF_LOGGING

typedef union {
  struct {
    idl4_word_t  _msgtag;
    idl4_word_t  _message_size;
    idl4_stringitem  _memmsg;
  }  _in;
  struct {
    idl4_word_t  _spacer[64];
    idl4_word_t  _msgtag;
  }  _out;
  struct {
    idl4_word_t  _spacer[128];
    idl4_inverse_stringitem  _str[16];
    idl4_word_t  _acceptor;
  }  _buf;
}  _param_logger_LogMessage;

typedef union {
  struct {
    CORBA_char  _varbuf[256];
  }  _in;
}  _memmsg_logger_LogMessage;

idl4_word_t  service_logger_LogMessage(idl4_threadid_t  _caller, _param_logger_LogMessage * _par);

inline void  logger_LogMessage_implementation(CORBA_Object  _caller, const logmessage_t  message, idl4_server_environment * _env);

// Channel 0:                        ID OFFS SIZE ALGN FLAGS BUF
//   R0: idl4_word_t  _msgtag         3    0    4    4 -p---  -1
//   R4: idl4_word_t  _message_size   2    4    4    4 x----  -1
//   M0: char _varbuf                 5    0  256    4 -----  -1
//   M-: CORBA_char  _message_buf     2   -1  256    1 x----  -1
//   S0: char message                 2    0  256    1 -----   0
// 
// Channel 1:                        ID OFFS SIZE ALGN FLAGS BUF
//   R-: idl4_word_t  _msgtag         4   -1    4    4 -p---  -1

#define IDL4_PUBLISH_LOGGER_LOGMESSAGE(_func) idl4_word_t  service_logger_LogMessage(idl4_threadid_t  _caller, _param_logger_LogMessage * _par)\
\
{ \
  idl4_server_environment  _env; \
  CORBA_char * g1; \
  idl4_word_t  _memvaridx = 0; \
  _memmsg_logger_LogMessage * _memmsg = (_memmsg_logger_LogMessage *)_par->_buf._str[15].ptr; \
\
  _env._action = 0;\
\
  /* unmarshal */ \
   \
  g1 = (CORBA_char *)&_memmsg->_in._varbuf[_memvaridx];\
  _memvaridx += ((_par->_in._message_size+3) & 0xFFFFFFFCU);\
\
  /* invoke service */ \
   \
  _func(_caller, g1, &_env);\
\
  if (IDL4_EXPECT_TRUE(_env._action == 0)) \
    { \
      /* jump back */ \
       \
      _par->_out._msgtag = (0 << 6)+0;\
      return 0; \
    } \
\
  return 4294967295U; \
} \

#define IDL4_PUBLISH_logger_LogMessage IDL4_PUBLISH_LOGGER_LOGMESSAGE

static inline void  logger_LogMessage_reply(CORBA_Object  _client)

{
  struct _reply_buffer {
    struct {
      idl4_word_t  _msgtag;
    }  _out;
  }  _buf;
  struct _reply_buffer * _par = &_buf;

  /* send message */
  
  _buf._out._msgtag = 0;
  L4_MsgLoad((L4_Msg_t *)((void*)_par));
  L4_Send_Timeout(_client, L4_ZeroTime);
}

#endif /* !defined(__logger_server_h__) */
